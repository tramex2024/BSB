// autobotLogic.js

const Autobot = require('./models/Autobot');
const bitmartService = require('./services/bitmartService');
const analyzer = require('./bitmart_indicator_analyzer');
const { placeOrder, getBalance, cancelOrder } = require('./services/bitmartService'); // Importar funciones necesarias

let io;
let intervalId;
let botIsRunning = false;
let currentLState = 'STOPPED';
let currentSState = 'STOPPED';

let activeBotOrders = [];
let botConfiguration = {}; // Guardaremos la configuración aquí
let AUTH_CREDS = {}; // Guardaremos las credenciales aquí

const TRADE_SYMBOL = 'BTC_USDT';
const MIN_USDT_VALUE_FOR_BITMART = 5.00; // Valor mínimo de orden en BitMart

/**
 * Establece la instancia de Socket.IO para emitir logs al frontend.
 * @param {object} socketIo - La instancia de Socket.IO.
 */
function setIo(socketIo) {
    io = socketIo;
}

/**
 * Emite un log al frontend a través de Socket.IO.
 * @param {string} message - El mensaje del log.
 * @param {string} type - El tipo de mensaje ('info', 'success', 'error', etc.).
 */
function log(message, type = 'info') {
    if (io) {
        io.emit('bot-log', { message, type, timestamp: new Date().toISOString() });
    }
    console.log(`[BOT LOG]: ${message}`);
}

/**
 * Actualiza el estado del bot en la DB y en el frontend.
 * @param {string} lState - Estado para el Long.
 * @param {string} sState - Estado para el Short.
 */
async function updateBotState(lState, sState) {
    try {
        currentLState = lState;
        currentSState = sState;

        const autobot = await Autobot.findOne({});
        if (autobot) {
            autobot.lstate = lState;
            autobot.sstate = sState;
            await autobot.save();
        }

        if (io) {
            io.emit('bot-state-update', { lstate: currentLState, sstate: currentSState });
        }
    } catch (error) {
        log(`Error al actualizar el estado del bot: ${error.message}`, 'error');
    }
}

/**
 * Lógica principal del bot que se ejecuta en un ciclo.
 */
async function botMainLoop() {
    if (!botIsRunning) return;
    try {
        const SYMBOL = botConfiguration.symbol || TRADE_SYMBOL;

        const ticker = await bitmartService.getTicker(SYMBOL);
        if (!ticker || !ticker.last) {
            log("No se pudo obtener el precio actual del ticker de BitMart. Reintentando.", 'error');
            return;
        }
        const currentPrice = parseFloat(ticker.last);
        log(`Precio actual de ${SYMBOL}: $${currentPrice.toFixed(2)}`, 'info');
        
        // Obtenemos los balances en cada ciclo, es crucial para la lógica.
        const balanceInfo = await getBalance(AUTH_CREDS);
        const usdtBalance = balanceInfo.find(b => b.currency === 'USDT');
        const availableUSDT = usdtBalance ? parseFloat(usdtBalance.available || 0) : 0;
        
        const btcBalance = balanceInfo.find(b => b.currency === 'BTC');
        const availableBTC = btcBalance ? parseFloat(btcBalance.available || 0) : 0;

        // --- LÓGICA DE LA ESTRATEGIA LONG ---
        switch (currentLState) {
            case 'RUNNING':
                log("Estado: RUNNING. Esperando señal de entrada de COMPRA.", 'info');
                const analysisResult = await analyzer.runAnalysis(currentPrice);
                
                if (analysisResult.action === 'BUY') {
                    log(`¡Señal de COMPRA detectada! Razón: ${analysisResult.reason}`, 'success');
                    const purchaseAmount = parseFloat(botConfiguration.purchaseUsdtAmount || 0);

                    if (availableUSDT >= purchaseAmount && purchaseAmount >= MIN_USDT_VALUE_FOR_BITMART) {
                        const buyOrder = await placeOrder(AUTH_CREDS, SYMBOL, 'buy', 'market', purchaseAmount);
                        if (buyOrder && buyOrder.order_id) {
                            activeBotOrders.push(buyOrder.order_id);
                            log(`Orden de compra colocada. ID: ${buyOrder.order_id}`, 'success');
                            // Aquí se actualizarían los detalles de la orden en la base de datos si fuera necesario
                            await updateBotState('BUYING', currentSState);
                        } else {
                            log('Error: La respuesta de la orden de compra no contiene un ID.', 'error');
                        }
                    } else {
                        log(`No hay suficiente USDT para la primera orden. Necesario: ${purchaseAmount.toFixed(2)}, Disponible: ${availableUSDT.toFixed(2)}. Cambiando a NO_COVERAGE.`, 'warning');
                        await updateBotState('NO_COVERAGE', currentSState);
                    }
                } else {
                    log(`Señal de ESPERA detectada. Razón: ${analysisResult.reason}`, 'info');
                }
                break;

            case 'BUYING':
                log("Estado: BUYING. Gestionando compras de cobertura...", 'info');

                // Lógica de venta por indicador mientras se está en BUYING
                const analysisResultForSell = await analyzer.runAnalysis(currentPrice);
                if (analysisResultForSell.action === 'SELL') {
                    log(`Indicador sugiere VENTA mientras estamos en BUYING. Transicionando a SELLING.`, 'warning');
                    await updateBotState('SELLING', currentSState);
                    // No hacemos 'break' para que la lógica de venta se ejecute inmediatamente.
                } else {
                    // Lógica de cobertura por DCA (aún por implementar, pero este es el lugar)
                    // Por ahora, solo esperamos.
                    log("Esperando condiciones para la próxima cobertura o venta.", 'info');
                }
                break;
            
            case 'SELLING':
                log("Estado: SELLING. Gestionando ventas...", 'info');
                // Lógica de trailing stop (aún por implementar, pero este es el lugar)
                log("Esperando condiciones para la venta.", 'info');
                // Ejemplo de venta:
                // const sellAmount = availableBTC;
                // if(sellAmount > 0) { await placeOrder(AUTH_CREDS, SYMBOL, 'sell', 'market', sellAmount); }
                break;

            case 'NO_COVERAGE':
                log("Estado: NO_COVERAGE. Esperando fondos o precio de venta.", 'warning');
                // Lógica de "trigger" de venta y recuperación de fondos
                if (availableUSDT >= parseFloat(botConfiguration.purchaseUsdtAmount || 0)) {
                    log("Fondos recuperados. Volviendo a estado RUNNING.", 'success');
                    await updateBotState('RUNNING', currentSState);
                } else {
                    log("Aún esperando fondos suficientes.", 'info');
                }
                break;

            case 'STOPPED':
                log("El bot está detenido.", 'info');
                break;

            default:
                log(`Estado desconocido del bot: ${currentLState}. Estableciendo a STOPPED.`, 'error');
                await updateBotState('STOPPED', currentSState);
                break;
        }

    } catch (error) {
        log(`Error en el ciclo del bot: ${error.message}`, 'error');
    }
}

/**
 * Inicia la estrategia del Autobot con una configuración específica.
 * @param {object} config - Objeto de configuración del bot.
 * @param {object} authCreds - Objeto con las credenciales de la API de BitMart.
 */
async function start(config, authCreds) {
    if (botIsRunning) return log('El bot ya está en ejecución.', 'warning');
    
    botConfiguration = config;
    AUTH_CREDS = authCreds;
    
    if (!botConfiguration || !AUTH_CREDS) {
        log('Error: Falta configuración o credenciales para iniciar el bot.', 'error');
        return;
    }

    botIsRunning = true;
    await updateBotState('RUNNING', 'RUNNING'); // Empieza en estado RUNNING
    log("El bot ha iniciado correctamente.", 'success');
    
    intervalId = setInterval(botMainLoop, botConfiguration.interval || 5000);
}

/**
 * Detiene la estrategia del Autobot.
 */
async function stop() {
    if (!botIsRunning) return log('El bot ya está detenido.', 'warning');
    
    if (intervalId) {
        clearInterval(intervalId);
        intervalId = null;
    }

    try {
        if (activeBotOrders.length > 0) {
            log(`Cancelando las ${activeBotOrders.length} órdenes activas del bot...`, 'info');
            for (const orderId of activeBotOrders) {
                await cancelOrder(AUTH_CREDS, botConfiguration.symbol, orderId);
                log(`Orden ${orderId} cancelada.`, 'success');
            }
        } else {
            log('No se encontraron órdenes activas del bot para cancelar.', 'info');
        }
        
        activeBotOrders = [];

    } catch (error) {
        log(`Error al cancelar órdenes: ${error.message}`, 'error');
    }

    botIsRunning = false;
    await updateBotState('STOPPED', 'STOPPED');
    log("El bot se ha detenido.", 'success');
}

module.exports = {
    setIo,
    start,
    stop,
};