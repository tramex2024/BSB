// BSB/server/src/au/utils/coverageLogicShort.js

// ðŸŸ¢ CORRECCIÃ“N: Sincronizamos importaciÃ³n con el Manager de Short
const { placeCoverageShortOrder } = require('../managers/shortOrderManager');
const { MIN_USDT_VALUE_FOR_BITMART } = require('./tradeConstants'); 

/**
 * Verifica las condiciones de cobertura (DCA UP) para la pierna Short.
 */
async function checkAndPlaceCoverageOrder(botState, availableUSDT, currentPrice, creds, config, log, updateBotState, updateSStateData, updateGeneralBotState) {
    
    // Obtenemos datos de sStateData (Short)
    const { ppc: pps, lastOrder, requiredCoverageAmount, nextCoveragePrice: dbNextPrice } = botState.sStateData || {};
    // âœ… CORRECCIÃ“N: Acceso a la nueva jerarquÃ­a de base de datos
    const { price_var, size_var, purchaseUsdt } = config.short || {}; 
    const currentSBalance = parseFloat(botState.sbalance || 0);

    // 1. BLOQUEO DE ORDEN DUPLICADA
    if (lastOrder && (['pending_fill', 'new', 'partially_filled'].includes(lastOrder.state))) {
        return; 
    }

    // 2. VALIDACIÃ“N DE INICIALIZACIÃ“N
    if (!pps || pps <= 0 || !dbNextPrice) {
        return;
    }

    // 3. CÃLCULO DE MONTO (LÃ³gica Exponencial)
    // ðŸ’¡ Priorizamos requiredCoverageAmount (Calculado en autobotCalculations.js)
    let nextUSDTNotional = parseFloat(requiredCoverageAmount || 0);
    
    if (nextUSDTNotional === 0) {
        // Fallback: Si no hay valor persistido, calculamos basÃ¡ndonos en el Ãºltimo monto o el inicial
        const lastAmount = parseFloat(lastOrder?.usdt_amount || purchaseUsdt || 0);
        nextUSDTNotional = lastAmount * (1 + (parseNumber(size_var) / 100));
    }

    const nextCoveragePrice = parseFloat(dbNextPrice);

    // 4. CONDICIÃ“N DE DISPARO (Short dispara si el precio SUBE)
    if (currentPrice >= nextCoveragePrice) { 
        
        log(`ðŸš€ Disparo Short (DCA UP): Target ${nextCoveragePrice.toFixed(2)} | Actual ${currentPrice.toFixed(2)} | Monto: ${nextUSDTNotional.toFixed(2)} USDT`, 'info');

        // 5. VERIFICACIÃ“N DE FONDOS
        const isSufficient = currentSBalance >= nextUSDTNotional && 
                             availableUSDT >= nextUSDTNotional && 
                             nextUSDTNotional >= MIN_USDT_VALUE_FOR_BITMART;

        if (isSufficient) {
            // âœ… CORRECCIÃ“N: Llamamos a la funciÃ³n correcta del shortOrderManager
            // Pasamos botState, el monto en USDT y las funciones de actualizaciÃ³n.
            await placeCoverageShortOrder(botState, nextUSDTNotional, log, updateGeneralBotState, updateBotState); 

        } else {
            const reason = currentSBalance < nextUSDTNotional 
                ? `LÃ­mite SBalance (${currentSBalance.toFixed(2)}) insuficiente` 
                : `Saldo real API (${availableUSDT.toFixed(2)}) insuficiente`;
                
            log(`âš ï¸ Cobertura Short abortada: ${reason}. Cambiando a NO_COVERAGE.`, 'warning');
            await updateBotState('NO_COVERAGE', 'short'); 
        }
    }
}

module.exports = { checkAndPlaceCoverageOrder };