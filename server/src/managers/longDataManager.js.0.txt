// BSB/server/src/managers/longDataManager.js

const Autobot = require('../../models/Autobot');
const { saveExecutedOrder } = require('../../services/orderPersistenceService');
const { logSuccessfulCycle } = require('../../services/cycleLogService');

const LSTATE = 'long';
const SELL_FEE_PERCENT = 0.001; // 0.1% (Comisi√≥n de Venta)
const BITMART_BUY_FEE_PERCENT = 0.001; // üõë NUEVA CONSTANTE: 0.1% (Comisi√≥n de Compra, ajusta si tienes descuentos)

/**
 * Maneja una compra exitosa (total o parcial) y actualiza la posici√≥n (PPC, AC, AI).
 */
async function handleSuccessfulBuy(botState, orderDetails, log) {
    // --- 1. EXTRACCI√ìN Y C√ÅLCULO DE COSTO REAL (CORREGIDO) ---
    const executedQty = parseFloat(orderDetails.filledSize || 0);
    const executedPrice = parseFloat(orderDetails.priceAvg || orderDetails.price || 0);
    
    // üõë CORRECCI√ìN CR√çTICA: Usar filledNotional para el costo base
    // La auditor√≠a confirm√≥ que filledNotional es Qty * Price, y 'fee' no se devuelve.
    let calculatedBaseCost = parseFloat(orderDetails.filledNotional || 0); 
    
    // Fallback de seguridad si filledNotional no est√° presente
    if (calculatedBaseCost <= 0) {
        calculatedBaseCost = executedQty * executedPrice;
    }

    // üõë CORRECCI√ìN CR√çTICA: Calcular el Fee si no viene en el 'orderDetails'
    // Prioriza el fee de la orden si existe, si no, lo calcula con la tasa fija.
    let executedFee = parseFloat(orderDetails.fee || 0); 
    
    if (executedFee === 0 && calculatedBaseCost > 0) {
        executedFee = calculatedBaseCost * BITMART_BUY_FEE_PERCENT;
        log(`ADVERTENCIA: Fee de Compra no encontrado. Calculado como ${executedFee.toFixed(8)} USDT (${(BITMART_BUY_FEE_PERCENT*100).toFixed(2)}% del costo base).`, 'warning');
    }
    
    // ‚úÖ Costo Total Real (Inversi√≥n Acumulada - AI): Costo Base + Comisi√≥n
    const actualExecutedCost = calculatedBaseCost + executedFee;

    log(`[DEBUG PPC] Qty: ${executedQty}, Price: ${executedPrice}, Costo Base (FilledNotional): ${calculatedBaseCost.toFixed(8)}, Fee Calculado: ${executedFee.toFixed(8)}, Final Cost (AI): ${actualExecutedCost.toFixed(8)}`, 'debug');

    if (executedQty <= 0 || executedPrice <= 0 || actualExecutedCost <= 0) {
        log('Error de procesamiento de compra: handleSuccessfulBuy llamado con ejecuci√≥n, precio o costo cero. Limpiando lastOrder.', 'error');
        await Autobot.findOneAndUpdate({}, { $set: { 'lStateData.lastOrder': null } });
        return;
    }

    // --- 2. C√ÅLCULO DEL NUEVO PRECIO PROMEDIO DE COMPRA (PPC) y AC ---
    const isFirstOrder = (botState.lStateData.orderCountInCycle || 0) === 0;
    const currentTotalQty = isFirstOrder ? 0 : parseFloat(botState.lStateData.ac || 0);
    const currentAI = isFirstOrder ? 0 : parseFloat(botState.lStateData.ai || 0);
    
    // newAI usa el actualExecutedCost CORREGIDO
    const newTotalQty = currentTotalQty + executedQty;
    const newAI = currentAI + actualExecutedCost;

    let newPPC = 0;

    if (newTotalQty > 0) {
        // F√≥rmula CORRECTA: AI / AC
        newPPC = newAI / newTotalQty; 
        if (isNaN(newPPC) || newPPC === Infinity) newPPC = currentAI;
    }

    // --- 3. GESTI√ìN DEL CAPITAL RESTANTE (LBalance y Refund) ---
    const intendedUsdtCostBlocked = parseFloat(botState.lStateData.lastOrder?.usdt_cost_real || 0);
    const refundAmount = intendedUsdtCostBlocked - actualExecutedCost;
    let finalLBalance = parseFloat(botState.lbalance || 0);

    if (refundAmount > 0.01) {
        finalLBalance = finalLBalance + refundAmount;
        log(`Devolviendo ${refundAmount.toFixed(2)} USDT al LBalance. Nuevo balance: ${finalLBalance.toFixed(2)} USDT.`, 'info');
    }

    // ------------------------------------------------------------------------
    // üí° C√ÅLCULO DE TARGETS DE COBERTURA Y VENTA
    // ------------------------------------------------------------------------
    const { price_var, size_var, purchaseUsdt, profit_percent } = botState.config.long;

    const coveragePercentage = price_var / 100;
    // Usamos el executedPrice real para calcular el pr√≥ximo punto de cobertura.
    const newNextCoveragePrice = executedPrice * (1 - coveragePercentage); 

    const lastOrderUsdtAmount = parseFloat(botState.lStateData.lastOrder?.usdt_amount || purchaseUsdt);
    const sizeVariation = size_var / 100;
    const newRequiredCoverageAmount = lastOrderUsdtAmount * (1 + sizeVariation);

    const profitPercentage = profit_percent / 100;
    // newLTPrice usa el newPPC CORREGIDO
    const newLTPrice = newPPC * (1 + profitPercentage); 

    log(`Targets calculados. Sell Price: ${newLTPrice.toFixed(2)}, Next Price: ${newNextCoveragePrice.toFixed(2)}, Next Amount: ${newRequiredCoverageAmount.toFixed(2)} USDT.`, 'info');

    // --- 4. ACTUALIZACI√ìN AT√ìMICA DE ESTADO EN LA BASE DE DATOS (CR√çTICO) ---
    const SYMBOL = botState.config.symbol || 'BTC_USDT';
    await saveExecutedOrder({ ...orderDetails, symbol: SYMBOL }, 'long');

    const atomicUpdate = {
        $set: {
            'lbalance': finalLBalance,
            'ltprice': newLTPrice,
            'lStateData.ac': newTotalQty,
            'lStateData.ai': newAI, // El AI corregido
            'lStateData.ppc': newPPC, // El PPC corregido
            'lStateData.lastExecutionPrice': executedPrice,
            'lStateData.nextCoveragePrice': newNextCoveragePrice,
            'lStateData.requiredCoverageAmount': newRequiredCoverageAmount,
            'lStateData.lastOrder': null,
            'lStateData.lNOrderMax': (botState.lStateData.lNOrderMax || 0) + 1,
            ...(isFirstOrder && {
                'lStateData.cycleStartTime': new Date()
            }),
        },
        $inc: {
            'lStateData.orderCountInCycle': 1,
            ...(isFirstOrder && { 'lcycle': 1 }),
        }
    };

    await Autobot.findOneAndUpdate({}, atomicUpdate);

    log(`[LONG] Transici√≥n completa. Nuevo PPC: ${newPPC.toFixed(2)}, Qty Total (AC): ${newTotalQty.toFixed(8)}.`, 'success');
}

// =========================================================================
// FUNCI√ìN HANDLER: L√ìGICA DE RECUPERACI√ìN DE CAPITAL Y CIERRE DE CICLO (MOVIDA DE LSelling.js)
// =========================================================================

/**
 * L√≥gica para manejar una orden de venta exitosa (cierre de ciclo Long).
 * @param {object} botStateObj - Estado del bot antes de la venta.
 * @param {object} orderDetails - Detalles de la orden de BitMart completada.
 * @param {object} dependencies - Dependencias inyectadas (incluye config, log, updateGeneralBotState, etc.).
 */
async function handleSuccessfulSell(botStateObj, orderDetails, dependencies) {
	// Aseguramos la extracci√≥n de todas las dependencias necesarias
	const { config, log, updateBotState, updateLStateData, updateGeneralBotState } = dependencies;
    
	try {
		// 1. C√ÅLCULO DE CAPITAL Y GANANCIA
		const { ac: totalBtcSold } = botStateObj.lStateData;
        const totalUsdtSpent = botStateObj.lStateData.ai;
		
		const sellPrice = parseFloat(orderDetails.priceAvg || orderDetails.price || 0);
		// Asumiendo que filledSize es la cantidad vendida o usando el total acumulado
		const filledSize = parseFloat(orderDetails.filled_volume || orderDetails.amount || totalBtcSold || 0);
		
		const totalUsdtRecoveredBRUTO = filledSize * sellPrice;
        const sellFeeUsdt = totalUsdtRecoveredBRUTO * SELL_FEE_PERCENT;    
        const totalUsdtRecoveredNETO = totalUsdtRecoveredBRUTO - sellFeeUsdt;
        const profitNETO = totalUsdtRecoveredNETO - totalUsdtSpent;
        	
        // ------------------------------------------------------------------------
        // üí° MODIFICACI√ìN: PERSISTENCIA HIST√ìRICA DE LA ORDEN DE VENTA (Reforzada)
        // ------------------------------------------------------------------------
        const SYMBOL = config.symbol || 'BTC_USDT';
        const orderToSave = {
            ...orderDetails,
            orderTime: new Date(orderDetails.createTime || orderDetails.orderTime || Date.now()),
            symbol: orderDetails.symbol || SYMBOL,
            type: orderDetails.type || 'MARKET',
            side: 'sell' // Asegurar el lado
        };

        const savedOrder = await saveExecutedOrder(orderToSave, LSTATE);
        if (savedOrder) {
            log(`Orden de VENTA Long ID ${orderDetails.orderId || 'ASUMIDA'} guardada en el historial de √ìrdenes.`, 'debug');
        }

        // ========================================================================
		// üü¢ BLOQUE: REGISTRO HIST√ìRICO DEL CICLO DE TRADING
		// ========================================================================
		const cycleEndTime = new Date();
		const cycleStartTime = botStateObj.lStateData.cycleStartTime;
		let durationHours = null;

		if (cycleStartTime) {
			const durationMs = cycleEndTime.getTime() - cycleStartTime.getTime();
			durationHours = durationMs / (1000 * 60 * 60);

			const cycleData = {
				strategy: 'Long', cycleIndex: (botStateObj.lcycle || 0) + 1, symbol: config.symbol,
				startTime: cycleStartTime, endTime: cycleEndTime, durationHours: durationHours,
				initialInvestment: totalUsdtSpent, finalRecovery: totalUsdtRecoveredNETO,
				netProfit: profitNETO, profitPercentage: (profitNETO / totalUsdtSpent) * 100,
				averagePPC: botStateObj.lStateData.ppc, finalSellPrice: sellPrice,
				orderCount: botStateObj.lStateData.orderCountInCycle, autobotId: botStateObj._id    
			};

			const savedCycle = await logSuccessfulCycle(cycleData);
			if (savedCycle) {
				log(`Resumen del ciclo Long ${cycleData.cycleIndex} guardado. Ganancia: ${profitNETO.toFixed(2)} USDT.`, 'success');
			} else {
				log(`ADVERTENCIA: Fall√≥ el registro del ciclo ${cycleData.cycleIndex} en la DB.`, 'warning');
			}
		} else {
			log('ADVERTENCIA: cycleStartTime faltante. No se pudo registrar el ciclo en el historial.', 'warning');
		}
		// ========================================================================
		// üü¢ FIN DEL BLOQUE DE REGISTRO
		// ========================================================================

		// 2. RECUPERACI√ìN DE CAPITAL OPERATIVO Y GANANCIA
		const newLBalance = botStateObj.lbalance + totalUsdtRecoveredNETO;
		
        // üõë CORRECCI√ìN DE RESETEO DE CAMPOS ROOT LEVEL (Seg√∫n an√°lisis de cleanState)
		await updateGeneralBotState({
			lbalance: newLBalance,
			total_profit: (botStateObj.total_profit || 0) + profitNETO,
			// Campos root level que deben resetearse a 0
            ltprice: 0, 
            lsprice: 0, 
            lcoverage: 0, 
            lnorder: 0,
            lprofit: 0, // A√±adido lprofit
			lcycle: (botStateObj.lcycle || 0) + 1
		});

		log(`Cierre de Ciclo Long Exitoso! Ganancia NETA: ${profitNETO.toFixed(2)} USDT.`, 'success');

		// 3. RESETEO DE DATOS DE CICLO ESPEC√çFICOS (lStateData)
        // üõë CORRECCI√ìN DE RESETEO DE CAMPOS LSTATE DATA (A√±adido 'pv')
		const resetLStateData = {
			ac: 0, ppc: 0, ai: 0, orderCountInCycle: 0, lastOrder: null, pm: 0, pc: 0, pv: 0,
            lastExecutionPrice: 0, nextCoveragePrice: 0, requiredCoverageAmount: 0,
            cycleStartTime: null
		}
		await updateLStateData(resetLStateData);

		// 4. TRANSICI√ìN DE ESTADO
        if (config.long.stopAtCycle) {
            log('Configuraci√≥n: stopAtCycle activado. Bot Long se detendr√°.', 'info');
            await updateBotState('STOPPED', LSTATE);
        } else {
            log('Configuraci√≥n: stopAtCycle desactivado. Transicionando a BUYING para iniciar la nueva compra.', 'info');
            await updateBotState('BUYING', LSTATE);
        }

	} catch (error) {
        log(`CRITICAL PERSISTENCE ERROR: Fall√≥ el reseteo del estado tras venta exitosa/asumida. Causa: ${error.message}`, 'error');
		log('Intentando limpieza de lastOrder y permitiendo reintento en el pr√≥ximo ciclo.', 'warning');
		try {
			await updateLStateData({ 'lastOrder': null });
		} catch (dbError) {
			 log(`FALLA DE RECUPERACI√ìN: No se pudo limpiar lastOrder. Revise la conexi√≥n/estado de la DB.`, 'error');
		}
	}
}

module.exports = {
    handleSuccessfulBuy,
    handleSuccessfulSell
};