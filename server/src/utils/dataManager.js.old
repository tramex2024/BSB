// BSB/server/src/utils/dataManager.js (CORRECCI√ìN FINAL - S√ìLO EXPORTACI√ìN)

const { log } = require('../logger'); 
// ‚úÖ Las importaciones de c√°lculo son correctas
const { 
    calculateLongTargets, 
    calculateNextTarget, 
    calculateNextCoverage 
} = require('../../autobotCalculations'); 
const Autobot = require('../../models/Autobot'); // Importar Mongoose Model aqu√≠ para uso interno

/**
 * Maneja una compra exitosa (total o parcial), actualiza la posici√≥n del bot
 * (PPC, AC, AI, lastExecutionPrice), y pasa al estado de gesti√≥n de posici√≥n (BUYING).
 */
async function handleSuccessfulBuy(botState, orderDetails, updateGeneralBotState, log) {
    // --- 1. EXTRACCI√ìN Y VALIDACI√ìN DE DATOS DE LA ORDEN ---
    
    // ** üí° Nuevo campo a√±adido en orderManager.js para incluir la comisi√≥n (0.1%) **
    const orderRealCost = parseFloat(botState.lStateData.lastOrder?.usdt_cost_real || 0); 
    
    const executedQty = parseFloat(orderDetails.filledSize || 0);       
    const executedAvgPrice = parseFloat(orderDetails.priceAvg || 0); 
    
    // Esto es el monto nominal que BitMart cobr√≥/ejecut√≥
    const actualUsdtSpent = parseFloat(orderDetails.notional || 0); 
    const intendedUsdtSpentNominal = parseFloat(botState.lStateData.lastOrder?.usdt_amount || 0);

    const finalExecutionPrice = executedAvgPrice > 0 ? executedAvgPrice : parseFloat(orderDetails.price || 0);
    
    if (executedQty <= 0 || finalExecutionPrice <= 0 || orderRealCost <= 0) { // üõë Validaci√≥n de orderRealCost
        log('Error de procesamiento de compra: handleSuccessfulBuy llamado con ejecuci√≥n, precio o costo real cero. Limpiando lastOrder.', 'error');
        await Autobot.findOneAndUpdate({}, { 'lStateData.lastOrder': null });
        return; 
    }

    // --- 2. C√ÅLCULO DEL NUEVO PRECIO PROMEDIO DE COMPRA (PPC) y AC ---
    
    const currentTotalQty = parseFloat(botState.lStateData.ac || 0); 
    // üí° CR√çTICO: Usar AI (Inversi√≥n acumulada) para el c√°lculo de PPC
    const currentTotalInvestment = parseFloat(botState.lStateData.ai || 0); 
    
    // üõë C√ÅLCULO CORREGIDO DE COSTO Y PPC
    
    // El costo real que va a la inversi√≥n es el que ya se dedujo (orderRealCost)
    const newTotalInvestment = currentTotalInvestment + orderRealCost; 
    
    const newTotalQty = currentTotalQty + executedQty;

    let newPPC = finalExecutionPrice; // Usar el precio de la √∫ltima ejecuci√≥n como fallback
    
    if (newTotalQty > 0) {
        // F√≥rmula del PPC corregida: (Costo Total Acumulado) / (Cantidad Total Acumulada)
        newPPC = newTotalInvestment / newTotalQty; 
        if (isNaN(newPPC)) newPPC = finalExecutionPrice; 
    }
    
    // --- 3. GESTI√ìN DEL CAPITAL RESTANTE (LBalance y Refund) ---

    // La l√≥gica de refund es compleja aqu√≠ porque el LBalance ya descont√≥ el 0.1% extra (orderManager.js).
    // Si la orden se ejecuta parcialmente, debemos revertir la parte del costo real no utilizada.
    
    // Costo Real Total = orderRealCost (ej. 5.147)
    // Costo Nominal Total = intendedUsdtSpentNominal (ej. 5.142)
    
    // Costo Nominal de lo ejecutado = executedQty * finalExecutionPrice
    // Lo que BitMart devuelve es el remanente del monto NOMINAL (intendedUsdtSpentNominal - actualUsdtSpent)
    
    // Para simplificar, asumimos que el LBalance ya fue deducido con el COSTO REAL.
    // Solo devolvemos el remanente si hubo una ejecuci√≥n parcial nominal.
    
    const usdtToRefundNominal = intendedUsdtSpentNominal - actualUsdtSpent; 
    let finalLBalance = parseFloat(botState.lbalance || 0);

    if (usdtToRefundNominal > 0.01) { 
        //‚ö†Ô∏è Nota: Esta l√≥gica de reembolso puede requerir ajuste fino para el 0.1% de comisi√≥n no gastada. 
        // Por simplicidad de esta correcci√≥n, usamos el monto nominal.
        finalLBalance = finalLBalance + usdtToRefundNominal;
        log(`Devolviendo ${usdtToRefundNominal.toFixed(2)} USDT al LBalance debido a ejecuci√≥n parcial/remito. Nuevo balance: ${finalLBalance.toFixed(2)} USDT.`, 'info');
    }
    
    // --- 4. ACTUALIZACI√ìN AT√ìMICA DE ESTADO EN LA BASE DE DATOS (CR√çTICO) ---

    const atomicUpdate = {
        $set: {
            'lbalance': finalLBalance,
            'lstate': 'BUYING', 
            'lStateData.ac': newTotalQty,
            'lStateData.ppc': newPPC,
            // üõë CR√çTICO: A√±adir y actualizar AI (Inversi√≥n Acumulada Total, incluyendo fees de compra)
            'lStateData.ai': newTotalInvestment, 
            'lStateData.lastExecutionPrice': finalExecutionPrice,
            'lStateData.lastOrder': null, 
            'lnorder': (botState.lnorder || 0) + 1,
        },
        $inc: {
            'lStateData.orderCountInCycle': 1, 
        }
    };
    
    log(`[AUDITOR√çA 1/3] -> ANTES de la actualizaci√≥n at√≥mica. PPC: ${newPPC.toFixed(2)}, AC: ${newTotalQty.toFixed(8)}, AI: ${newTotalInvestment.toFixed(2)}`, 'debug');

    const updatedBot = await Autobot.findOneAndUpdate({}, atomicUpdate, { new: true }); 

    if (updatedBot) {
        log(`[AUDITOR√çA 2/3] -> DESPU√âS de actualizar. LBalance final: ${updatedBot.lbalance.toFixed(2)} USDT.`, 'debug');
        log(`[AUDITOR√çA 3/3] -> VERIFICACI√ìN EN DB. PPC le√≠do: ${updatedBot.lStateData.ppc.toFixed(2)}, AC le√≠do: ${updatedBot.lStateData.ac.toFixed(8)}, AI le√≠do: ${updatedBot.lStateData.ai.toFixed(2)}, LState: ${updatedBot.lstate}`, 'debug');
    } else {
        log('[AUDITOR√çA 2/3 y 3/3] -> ERROR: No se encontr√≥ el documento de Autobot despu√©s de la actualizaci√≥n.', 'error');
        return;
    }

    log(`[LONG] Orden confirmada. Nuevo PPC: ${newPPC.toFixed(2)}, Qty Total (AC): ${newTotalQty.toFixed(8)}, Inversi√≥n Total (AI): ${newTotalInvestment.toFixed(2)}. Precio de ejecuci√≥n: ${finalExecutionPrice.toFixed(2)}. Transicionando a BUYING.`, 'success');
}

// L√≥gica para manejar una orden de venta exitosa (cierre de ciclo Long).
async function handleSuccessfulSell(botStateObj, orderDetails, dependencies) {
    const { handleSuccessfulSell: LSellingHandler } = require('../states/long/LSelling');
    await LSellingHandler(botStateObj, orderDetails, dependencies);
}

// L√≥gica de reseteo (asume que existe)
async function resetAndInitializeBot(log) {
    const Autobot = require('../../models/Autobot'); 
    
    const currentBot = await Autobot.findOne({});
    
    const config = currentBot ? currentBot.config : { /* ... tus valores por defecto ... */ }; 
    const initialLBalance = config.long.amountUsdt || 0; 
    const totalProfit = currentBot ? currentBot.total_profit : 0; 
    
    await Autobot.deleteMany({});
    log('Documento Autobot eliminado completamente.', 'error');
    
    const newBotData = {
        "lstate": "RUNNING", 
        "sstate": "RUNNING",
        "config": config,
        "total_profit": totalProfit,
        "lbalance": initialLBalance, 
        "sbalance": config.short.amountBtc || 0, 
        // üõë CR√çTICO: A√±adir 'ai': 0 al reseteo
        "lStateData": { "ppc": 0, "ac": 0, "ai": 0, "ppv": 0, "av": 0, "orderCountInCycle": 0, "lastOrder": null, "pm": 0, "pc": 0, "requiredCoverageAmount": 0, "nextCoveragePrice": 0 },
        "sStateData": { "ppc": 0, "ac": 0, "ppv": 0, "av": 0, "orderCountInCycle": 0, "lastOrder": null, "pm": 0, "pc": 0, "requiredCoverageAmount": 0, "nextCoveragePrice": 0 },
        "lcycle": 0, "lnorder": 0, "ltprice": 0,
        "scycle": 0, "snorder": 0, "stprice": 0,
    };
    
    const newAutobot = new Autobot(newBotData);
    await newAutobot.save();
    
    log(`Documento Autobot creado. LBalance inicializado a ${initialLBalance} USDT. Listo para operar.`, 'info');
}

module.exports = {
    handleSuccessfulBuy,
    handleSuccessfulSell,
    resetAndInitializeBot,
    // ‚úÖ √öNICA EXPORTACI√ìN DE FUNCI√ìN HELPER NECESARIA EN ESTE ARCHIVO
    calculateLongTargets 
};